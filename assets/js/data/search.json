[ { "title": "Monitoring Kontainer Docker Menggunakan Prometheus dan Grafana", "url": "/posts/monitoring-kontainer-docker-menggunakan-prometheus-dan-grafana/", "categories": "", "tags": "containerization, docker, docker-compose, monitoring, prometheus, grafana", "date": "2022-03-22 21:36:00 +0700", "snippet": "Tech Stack Prometheus Grafana cAdvisor DockerPrasyaratIni adalah lanjutan dari post sebelumnya, Implementasi Kontainerisasi dan CI (Continuous Integration) Sederhana Menggunakan Jenkins. Agar lebih rapi, saya meletakkan Prometheus dan Grafana di satu jaringan Docker yang sama dengan kontainer yang dibuat di post sebelumnya, Jenkins dan Redis. Silahkan sesuaikan file docker-compose.yml jika ingin dibuat berbeda jaringan. Lihat detail jaringan yang dibuat oleh Docker dengan cara docker network ls dan docker network inspect network_nameInstalasiCp. 1: Setup KontainerSimpan file docker-compose.yml dan file config prometheus.yml berikut ini di dalam satu direktori yang sama.# docker-compose.ymlversion: &#39;3.8&#39;services: prometheus: image: prom/prometheus:latest container_name: prometheus volumes: - ./prometheus.yml:/etc/prometheus/prometheus.yml command: - &#39;--config.file=/etc/prometheus/prometheus.yml&#39; - &#39;--web.enable-lifecycle&#39; depends_on: - cadvisor ports: - 9090:9090 networks: - jenkins_network cadvisor: image: gcr.io/cadvisor/cadvisor:latest container_name: cadvisor ports: - 8080:8080 volumes: - /:/rootfs:ro - /var/run:/var/run:ro - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:ro command: - privileged=true networks: - jenkins_network node-exporter: image: prom/node-exporter:latest container_name: node-exporter ports: - 9100:9100 networks: - jenkins_network grafana: image: grafana/grafana:latest container_name: grafana user: &quot;1000&quot; environment: - GF_SECURITY_ADMIN_PASSWORD=admin depends_on: - prometheus ports: - 3000:3000 networks: - jenkins_networknetworks: jenkins_network: external: true## IMPORTANT:## This project is designed to be on the same network as the Jenkins network: &#39;jenkins_network&#39;.## How to do that? Define name of jenkins network in every container (services.&amp;lt;container_name&amp;gt;.networks)## and set networks.&amp;lt;network_name&amp;gt;.external to true.# prometheus.ymlglobal: scrape_interval: 15s external_labels: monitor: &#39;Monitoring&#39;scrape_configs: - job_name: &#39;prometheus&#39; static_configs: - targets: [&#39;localhost:9090&#39;] - job_name: &#39;cAdvisor&#39; static_configs: - targets: [&#39;cadvisor:8080&#39;] - job_name: &#39;node-exporter&#39; static_configs: - targets: [&#39;node-exporter:9100&#39;]Jalankan perintah berikut di dalam direktori di mana kedua file tersebut berada:$ docker-compose up -dValidasi bahwa kontainer telah berjalan dengan benar:$ docker psCp. 2: Validasi cAdvisorcAdvisor bertugas untuk mengumpulkan informasi mengenai semua kontainer yang sedang berjalan. Informasi ini nantinya diambil oleh Prometheus lalu diteruskan ke Grafana. Di Grafana inilah informasi disajikan dalam bentuk grafik.Pastikan cAdvisor telah berjalan dengan baik dengan cara akses ke dashboard cAdvisor http://localhost:8080/docker melalui browser. Lihat di bagian Subcontainers. Semua kontainer yang sedang berjalan ditampikan di sini.Jika daftar kontainer dapat ditampilkan oleh cAdvisor, silahkan skip ke bagian Setup Grafana.Namun jika tidak ada kontainer yang muncul sedangkan perintah docker ps menampilkan sebaliknya, dan jika kamu menggunakan WSL 2, maka besar kemungkinan cAdvisor salah dalam mencari ‘sumber’ kontainer. Ketahui errornya terlebih dahulu dengan cara:$ docker logs -f cadvisorJika ada banyak error yang bertuliskan failed to identify the read-write layer ID for container ... open /rootfs/var/lib/docker ... no such file or directory, maka jalankan perintah berikut ini. Secara default root directory Docker berada di /var/lib/docker. Khusus untuk WSL, lokasinya berada di tempat yang berbeda. Saya belum bisa menjamin apakah lokasinya selalu di wsl\\docker-desktop-data\\version-pack-data\\community\\docker. Mohon dipastikan terlebih dahulu. Link terkait: github.com/google/cadvisor/issues/2648.$ cd /mnt$ sudo mkdir my-docker$ sudo mount -t drvfs &#39;\\\\wsl$\\docker-desktop-data\\version-pack-data\\community\\docker&#39; /mnt/my-dockerPerintah di atas akan membuat direktori baru yang bernama my-docker lalu menyambungkan root directory Docker yang berada di luar Ubuntu ke direktori /mnt/my-docker yang berada di dalam Ubuntu.Setelah menjalankan perintah di atas, ubah baris 27 di file docker-compose.yml dari ini:- /var/lib/docker/:/var/lib/docker:roMenjadi ini:- /mnt/my-docker/:/rootfs/var/lib/docker:roLalu silahkan build ulang dengan cara:$ docker-compose up -dValidasi kembali melalui URL yang sama. Seharusnya cAdvisor sudah bisa memperoleh data kontainer.Setup GrafanaAkses dashboard Grafana di http://localhost:3000. Login dengan username admin dan password admin.Agar Grafana terhubung ke Prometheus, kita harus menambahkan data source baru dengan cara klik Data Sources lalu pilih opsi Prometheus. Grafana akan mengarahkan kita ke halaman pengaturan. Di sini cukup isi form URL http://prometheus:9090. Gulir ke paling bawah halaman dan klik Save &amp;amp; Test. Baik Grafana dan Prometheus sama-sama berada di satu jaringan Docker yang sama. Docker secara otomatis menghubungkan nama service (lihat baris 4 di docker-compose.yml) ke alamat IP-nya. Karena itulah, hanya dengan menuliskan prometheus, Grafana bisa langsung tersambung ke kontainer Prometheus.Langkah selanjutnya adalah merancang layout dashboard. Agar jauh lebih praktis, kita gunakan saja dashboard yang tersedia di internet. Caranya, silahkan navigasi ke menu Create lalu klik Import.Di form Import via Grafana.com, isikan 893. Ini adalah ID dari dashboard grafana.com/grafana/dashboards/893. Jangan lupa klik Load. Selanjutnya, isi nama dashboard di form Name kemudian pilih Prometheus pada menu dropdown Select a Prometheus Data Source. Klik Import.Selesai.Tautan Eskternal prometheus.io/docs/guides/cadvisor/#monitoring-docker-container-metrics-using-cadvisor" }, { "title": "Implementasi Kontainerisasi dan CI (Continuous Integration) Sederhana Menggunakan Jenkins", "url": "/posts/implementasi-kontainerisasi-dan-ci-sederhana-menggunakan-jenkins-di-docker/", "categories": "", "tags": "ci-cd, containerization, jenkins, dsl, docker, docker-compose, dockerfile, redis, webhook", "date": "2022-03-21 07:26:00 +0700", "snippet": "Tech StackTopik yang akan dibahas meliputi: Kontainer: Jenkins Redis Docker Docker Compose Dockerfile Jenkins: DSL Job WebhookOverviewDi posting kali ini kita akan men-setup Jenkins dan Redis di dua kontainer terpisah menggunakan Docker, membuat Job Jenkins dengan jenis Freestyle Project yang berisi task sederhana untuk get dan set key Redis, memginstal plugin DSL dan membuat Seed Job sehingga semua Job lainnya dapat dibuat otomatis dengan hanya satu aksi tanpa harus klik sana klik sini (alias configuration as code), serta mengunggah script DSL ke GitHub yang nantinya dihubungkan melalui webhook Smee agar dengan hanya mem-push ke GitHub, semua perubahan secara otomatis ter-apply ke Jenkins (alias continuous integration).FAQKenapa Kontainer?Jenkins dan Redis diinstal di kontainer agar tidak bergantung pada komputer host (laptop kamu). Apapun yang terjadi pada komputer host dan kontainer, akan mudah di-restore. Jika di kemudian hari Jenkins dan Redis tidak dibutuhkan lagi, cukup hapus kontainer dan image-nya saja (serta volume). Tidak bakal ada file sampah tersisa di komputer host.Apa itu DSL?DSL adalah plugin Jenkins yang memungkinkan kita menerapkan praktik configuration as code. Ini adalah solusi bagus karena semua Job akan tersimpan dengan baik di repositori (misalnya di GitHub) karena tidak perlu lagi mengklik ini itu di dashboard Jenkins untuk membuat Job dan semua perubahan konfigurasi akan tercatat di GitHub. Konfigurasi tersimpan di hanya satu tempat. Single source of truth. Selain itu, jika nantinya ada masalah pada Jenkins, semua konfigurasi dapat di-restore dengan cepat.Prasyarat Docker sudah diinstal Repositori GitHub sudah disiapkanInstalasi dan KonfigurasiCp. 1: Setup KontainerSimpan file docker-compose.yml dan Dockerfile berikut ini di dalam satu direktori yang sama.# docker-compose.ymlversion: &#39;3.8&#39;services: jenkins: build: context: . dockerfile: Dockerfile container_name: jenkins privileged: true user: root ports: - 8081:8080 - 50001:50000 volumes: - ~/docker-volume/jenkins:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock networks: - network redis: image: redis container_name: redis ports: - 6379:6379 networks: - network command: redis-server --save 20 1 --requirepass 12345678 --loglevel warningnetworks: network: driver: bridge# DockerfileFROM jenkins/jenkins:ltsUSER root# install npm and Smee (webhook payload delivery service)RUN curl -fsSL https://deb.nodesource.com/setup_17.x | bash -RUN apt updateRUN apt install -y nodejsRUN npm install --global smee-client# install screen to enable Smee run in backgroundRUN apt install -y screen# install redis-cli commandRUN apt install -y redis-toolsJalankan perintah berikut di dalam direktori di mana kedua file tersebut berada:$ docker-compose up -dValidasi bahwa container telah berjalan dengan benar:$ docker ps# output:CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb4bc27a05497 jenkins_jenkins &quot;/sbin/tini -- /usr/…&quot; 11 hours ago Up 45 minutes 0.0.0.0:8081-&amp;gt;8080/tcp, 0.0.0.0:50001-&amp;gt;50000/tcp jenkins6dc414e4d7aa redis &quot;docker-entrypoint.s…&quot; 11 hours ago Up 45 minutes 0.0.0.0:6379-&amp;gt;6379/tcp redisCp. 2: Setup JenkinsInstall JenkinsAkses localhost:8081 di browser. Halaman instalasi Jenkins akan muncul dan akan meminta temporary admin password. Jalankan perintah berikut untuk mengetahuinya:$ docker logs -f jenkins# outputJenkins initial setup is required. An admin user has been created and a password generated.Please use the following password to proceed to installation:1906342b77f244c79ea6a24f28959b8eDi halaman Customize Jenkins, pilih Install Suggested Plugins. Tunggu hingga semua plugin terinstal. Perhatikan bahwa menu Select Plugin to Install tidak akan menampilkan semua plugin yang tersedia di internet, termasuk DSL. Plugin DSL hanya bisa dperoleh di menu Plugin Manager ketika Jenkins telah selesai diinstal.Dashboard JenkinsInstall Plugin DSLJika proses instalasi Jenkins telah selesai, pada menu sidebar di halaman awal dashboard (gambar di atas), klik Manage Jenkins &amp;gt; Manage Plugins &amp;gt; Available &amp;gt; cari job dsl. Centang dan klik Install Without Restart.Terakhir, klik menu Manage Jenkins yang ada pada sidebar di halaman awal dashboard. Klik Configure Global Security, uncheck Enable script security for Job DSL scripts. Klik Save. Langkah ini diperlukan agar fitur keamanan Jenkins membolehkan Jenkins untuk mengeksekusi file DSL script (lihat langkah selanjutnya).Buat Seed JobSeed Job adalah istilah yang mengacu pada Job khusus DSL yang fungsinya sebagai generator Job lain. Seed Job ini berjalan berdasarkan file DSL script yang nantinya kita sediakan.Di sidebar halaman awal dashboard, klik New Item, ketik nama Seed Job, misalnya Seed-Job-DSL. Pilih Freestyle Project lalu klik OK. Tunggu hingga Seed Job selesai dibuat dan Jenkins akan mengarahkan kita ke halaman Configure.Di bagian Build, klik menu dropdown Add Build Step lalu pilih Process Job DSLs. Masih di bagian Build, pilih Look on Filesystem dan ketik job.groovy di kolom isian DSL Script.Build SectionUntuk integrasi ke repositori, masih di halaman Configure yang sama, centang GitHub hook trigger for GITScm polling di bagian Build Triggers. Kemudian, pilih Git di bagian Source Code Management. Di sini, cukup 2 kolom isian saja yang harus disesuaikan: Repository URL dan Branch Specifier. Repository URL diisi dengan nama repositori file job.groovy disimpan. Sedangkan Branch Specifier isi saja main.Build Triggers SectionSource Code Management SectionSelesai. Jangan lupa klik Save.Tambah CredentialLangkah ini diperlukan untuk me-masking password Redis yang telah kita definisikan di file docker-compose.yml pada baris ke 26. Password ini digunakan oleh Jenkins tiap kali mengakses Redis, baik untuk memperoleh atau mengeset suatu key. Alih-alih meng-hardcode password yang tentunya tidak aman, tambahkan password ini ke fitur Credentials Jenkins.Caranya, klik username admin yang ada di header kanan atas (sebelah kiri tombol logout), lalu klik Credentials, klik Jenkins yang ada di bagian Stores from Parent, klik Global Credentials, lalu klik Add Credentials. Pada menu dropdown Kind, pilih Secret Text, lalu isi kolom isian Secret dengan password Redis, dalam hal ini 12345678. Isi juga ID dengan nama kredensialnya, yaitu REDIS_PASSWORD. Klik OK.Cp. 3: Unggah DSL Script ke RepoBuat file baru dengan nama job.groovy.// job.groovyjob(&#39;JOB-02-FREESTYLE-PROJECT-02-REDIS&#39;){ description(&#39;Get or set Redis key.&#39;) parameters{ choiceParam(&#39;Action&#39;, [&#39;Getall&#39;, &#39;Get&#39;, &#39;Set&#39;]) stringParam(&#39;Key&#39;) stringParam(&#39;Value&#39;) } wrappers { credentialsBinding { string(&#39;REDIS_PASSWORD&#39;, &#39;REDIS_PASSWORD&#39;) } } steps { shell(&#39;&#39;&#39;#!/bin/bashif [[ &quot;$Action&quot; == &quot;Getall&quot; ]]; then redis-cli -h redis -p 6379 -a $REDIS_PASSWORD keys &#39;*&#39;elif [[ &quot;$Action&quot; == &quot;Get&quot; ]]; then redis-cli -h redis -p 6379 -a $REDIS_PASSWORD get $Keyelif [[ &quot;$Action&quot; == &quot;Set&quot; ]]; then redis-cli -h redis -p 6379 -a $REDIS_PASSWORD set $Key $Valuefi &#39;&#39;&#39;) }}Simpan file tersebut ke repositori.$ git add job.groovy$ git commit -m &quot;create job.groovy&quot;$ git push origin mainCp. 4: Setup WebhookBuat Channel Baru di SmeeKunjungi smee.io di browser. Klik Start a New Channel. Simpan baik-baik URL-nya. Kalau perlu di-bookmark.Jalankan Smee ClientBeralih ke kontainer Jenkins. Masuk ke kontainer dengan cara:$ docker exec -it jenkins bashJalankan perintah berikut untuk membuat session Screen baru, agar Smee client dapat berjalan secara background.$ screen -S smeeJalankan Smee client.$ smee --url https://smee.io/blablabla --path /github-webhook/ --port 8080Deatach Screen dengan cara menekan tombol ctrl + A + D. Lalu keluar dari kontainer dengan menekan tombol ctrl + D.Tambah Webhook di GitHubDi repositori GitHub tempat di mana file job.groovy disimpan, klik menu Settings, Webhooks, Add Webhook.Isi Payload URL dengan URL Smee. Lalu pilih application/json di menu dropdown Content Type. Klik Add Webbhook.Cp. 5: Enjoy!Yup, selesai.Tiap kali kamu melakukan perubahan di repositori melalui perintah git push di komputermu, Jenkins akan secara otomatis menjalankan DSL script dan meng-apply perubahan tersebut. Katakanlah kamu membuat Job baru yang berisi task untuk menambah data ke database MySQL. Dengan hanya git push, Job tersebut langsung muncul di Jenkins dan siap pakai." }, { "title": "Virtualisasi vs Kontainerisasi, Docker dan Kubernetes", "url": "/posts/konsep-virtualisasi-kontainerisasi-docker-kubernetes/", "categories": "", "tags": "virtualization, containerization, cloud, docker, kubernetes", "date": "2022-03-10 22:30:00 +0700", "snippet": "Sumber: incredibuild.comAda dua istilah yang sering terucap oleh mereka yang menggeluti dunia cloud computing, yaitu virtualisasi dan kontainerisasi. Ada pula sebutan virtual machine, Docker, dan Kubernetes. Makhluk seperti apa mereka ini?Berikut ini saya jelaskan secara kronologis, dimulai dari definisi komputasi awan, virtualisasi, kontainerisasi, Docker, hingga berakhir di Kubernetes.Komputasi AwanAwan adalah metafora internet. Oleh karenanya, komputasi awan adalah komputer dan segala macam jaringan serta infrastruktur IT yang berada di internet. Isitlah awan juga merupakan abstraksi dari suatu sistem kompleks yang disembunyikan. Instagram, Gojek, Bukalapak, Spotify, dan Netflix, semua data dan code-nya tidak berada di masing-masing perangkat kita, melainkan berada di internet.Komputasi awan memungkinkan pemilik Instagram, Gojek, dan aplikasi lainnya, untuk menggunakan sumber daya komputer secara on-demand dan hanya bayar sesuai penggunaan. On-demand berarti sumber daya boleh diubah sesuka hati. Hari ini RAM server 8 GB, besoknya diubah jadi 16 GB. Bandingkan dengan zaman dulu, di mana pemilik aplikasi menyewa server fisik dengan spesifikasi yang tidak mudah diubah karena ada “masa kontraknya”. Selain itu, biaya sewa juga selalu sama, meskipun penggunaan sumber dayanya sedang rendah.Beberapa contoh penyedia layanan komputasi awan yang populer yaitu Google Cloud Platform, Amazon Web Services, Microsoft Azure, IBM Cloud, Alibaba Cloud, dan Oracle Cloud Infrastructure.Sumber: miro.medium.comVirtualisasiDahulu, aplikasi disimpan di server fisik. Ada kalanya aktivitas dan jumlah pengguna berubah fluktuatif meningkat dan menurun. Agar dapat menampung jumlah pengguna yang semakin banyak, server harus ditingkatkan spesifikasinya yang mencakup CPU, RAM, dan harddisk. Butuh waktu berjam-jam bahkan hitungan hari untuk menyelesaikannya.Hingga akhirnya komputer virtual (disebut juga VM atau virtual machine) lahir, memulai masa virtualisasi. Sederhananya, komputer VM (guest) dijalankan di atas komputer lain (host). VM ini punya sistem operasinya sendiri. Perangkat keras komputer host diambil sebagian secara virtual untuk diberikan ke VM. Satu komputer host bisa menjadi inang bagi banyak VM.Teknologi ini tentu lebih cepat daripada server fisik. Spesifikasi dapat diubah hanya dalam hitungan detik. Perubahan hanya bermodalkan klik, geser, atau bentuk interaksi lainnya di peramban. Tidak perlu lagi datang ke data center, narik kabel, colok sana colok sini.Sumber: eginnovations.comKontainerisasiManusia memang tidak pernah puas. Virtualisasi masih dianggap lambat. Bayangkan begini, developer Gojek baru saja selesai membuat fitur baru, suatu fitur “pesan sekarang, pakai nanti” (eh, sudah ada belum ya?). Anggap saja belum. Fitur ini masih di environment staging dan akan di-deploy ke environment production. Artinya, fitur ini masih ada di internal mereka, belum dirilis ke publik, ke kita-kita ini.Seperti yang telah dijelaskan di tiga paragraf sebelumnya, VM adalah komputer nyata namun virtual. Ia berisi sistem operasi lengkap, aplikasi, dan konfigurasi serta dependency dari aplikasi itu sendiri. Proses deploy ke production, yaitu proses mengganti versi yang lama dengan yang baru, akan memakan waktu beberapa menit, setengah jam, atau bahkan sejam lebih.Hingga akhirnya kontainerisasi lahir. Sebuah kontainer jauh lebih ringan, ekonomis, dan skalabel dibandingkan dengan VM. Adanya kontainerisasi membuat aplikasi, entah itu frontend, backend, dan database, menjadi lebih terisolasi di dalam kontainernya masing-masing. Tidak bergantung pada host-nya sehingga mudah dipindah-pindah.Sumber: eginnovations.comVM dan Kontainer dianalogikan sebagai rumah dan unit apartemen. Sumber: lukewilson.netKontainer hanya berisi aplikasi, konfigurasi, dan dependency-nya saja. Tidak heran ukurannya hanya dalam hitungan MB, alih-alih VM yang berukuran sekian GB. Proses deploy menjadi jauh lebih cepat. Jika setelah deploy ternyata ada bug atau error, aplikasi juga akan lebih cepat di-rollback untuk mengembalikan ke versi sebelumnya. Coba bandingkan dengan VM dan server fisik, pengguna mungkin sudah keburu teriak-teriak di media sosial.Perbandingan arsitektur tradisional vs virtual vs kontainer. Sumeber: kubernetes.ioDockerDocker adalah salah satu perangkat lunak yang memungkinkan aplikasi dapat dikemas ke dalam bentuk paket yang disebut kontainer. Bagaimana kontainer dibuat? Apa yang harus saya mulai sebagai developer? Singkatnya begini:1. Code - Buat cetak biru dari sebuah image. Cetak biru ini berupa file bernama Dockerfile. File ini mendefinisikan base image, dependency, dan default command. Isi Dockerfile kurang lebih seperti ini.FROM node:alpineWORKDIR &#39;/app&#39;COPY package.json .RUN npm installCOPY . .CMD [&quot;npm&quot;,&quot;start&quot;]2. Build - Jalankan perintah docker build untuk membuat image.3. Push - Unggah image ke server, baik secara langsung atau melalui registry (contohnya Docker Hub) menggunakan perintah docker push.4. Run - Jalankan kontainer berdasarkan image yang telah dibuat untuk menggantikan kontainer yang lama. Jalankan serangkaian perintah docker pull, docker stop, dan docker run.Cara di atas hanya salah satu dari sekian cara yang tersedia. Banyak jalan menuju Roma.KubernetesBayangkan sebuah pertunjukan orkestra. Meski terdiri dari puluhan hingga ratusan musisi, pertunjukan musik tetap berjalan lancar dan seirama. Tidak ada yang temponya lebih cepat, tidak ada juga yang lebih lambat.Sekarang, bayangkan kita telah men-deploy ratusan kontainer ke production. Akan sangat rumit jika seluruh aktivitas per-kontainer-an masih diajalnkan secara manual. Misalnya saja jika mengikuti workflow Docker yang saya jabarkan sebelumnya, di poin ke-4, aplikasi akan mengalami downtime. Pengguna tidak akan dapat mengakses aplikasi selama proses deploy tersebut.Inilah peran Kubernetes, yaitu sebagai orkestrator kontainer yang melingkupi computing, networking, dan storage. Kubernetes memastikan segala sesuatunya berjalan baik. Kubernetes juga mengambil alih pekerjaan yang tidak seperlunya kita lakukan seperti menskalakan aplikasi ketika sedang ramai pengguna, menambah atau mengurangi jumlah node tiap kali kehabisan sumber daya perangkat keras, dan 1001 hal lainnya. Semua berjalan secara mulus dalam hitungan detik tanpa mematikan aplikasi.Kita hanya cukup mendifinisikan apa saja yang kita inginkan di dalam satu set file konfigurasi. Paradigma yang digunakan ketika menggunakan Kubernetes adalah deklaratif alih-alih imperatif.ArsitekturArsitektur Kubernetes. Sumeber: cncf.ioFlow komunikasi tiap komponen Kubernetes. Sumeber: kubernetes.ioFlow komunikasi antara master dan nodeTerminologiPod ― adalah objek terkecil yang dapat kita buat di Kubernetes. Ia adalah tempat di mana kontainer berjalan. Pod terdiri dari satu atau lebih kontainer.Node (worker node) ― adalah mesin, baik fisik maupun virtual, yang merupakan worker machine tempat di mana pod berada. Node terdiri dari satu atau lebih pod.Kluster ― adalah sekumpulan node yang dikelompokkan bersama. Dengan cara ini bahkan jika satu node mati, aplikasi masih dapat diakses melalui node lain.Master (control plane) ― bertanggungjawab dalam mengelola semuanya. Beberapa contohnya yaitu menyimpan informasi mengenai klsuter, memonitori node, dan pemindahan beban kerja dari node yang mati ke node lain.Container runtime ― adalah perangkat lunak yang harus ada agar kontainer dapat berjalan. Pada gambar ke-2 di atas, container runtime menggunakan Docker. Selain Docker, ada banyak pilihan lain seperti Containerd dan CRI-O.Instal KubernetesKubernetes bisa dijalankan di local machine (laptop atau desktop) dengan berupa single-node cluster. Saya menyarakan menggunakan Docker Desktop karena Docker sudah menyediakan Kubernetes. Cukup ke menu Pengaturan, submenu Kubernetes, klik Enable Kubernetes. Silahkan lihat bagaimana cara menginstal Docker di sini terlebih dahulu.Selain local machine, khususnya untuk keperluan production, Kubernetes dijalankan sebagai managed di penyedia layanan komputasi awan. Beberapa contohnya seperti GKE (Google Kubernetes Engine) dan EKS (Amazon Elastic Kubernetes Service).Bacaan Lanjutan Bagaimana Cara Men-deploy aplikasi di Kubernetes di Lokal (Laptop)? Bagaimana Cara Men-deploy aplokasi di Kubernetes di Google Cloud Platform (GKE)?Tautan Eksternal Dokumentasi Kubernetes Dokumentasi Docker Workflow Pembuatan Kontainer Menggunakan Docker Video Pembelajaran Docker dan Kubernetes di Udemy" }, { "title": "Bikin Visual Studio Code Jadi Lebih Minimalis dan Canggih [WIP]", "url": "/posts/percanggih-vscode/", "categories": "", "tags": "vscode, ide, windows, wsl, git, shell, terminal, zsh", "date": "2022-03-01 22:13:00 +0700", "snippet": " “Posting ini masih ditandai sebagai WIP (work in progress).”Mirip seperti posting sebelumnya yang berjudul Percantik Tampilan Windows Terminal WSL Ubuntu Menggunakan Zsh, kali ini yang menjadi kelinci percobaan beralih dari Windows Terminal ke VS Code alias Visual Studio Code.SebelumSesudahSiapa yang tidak mengenal VS Code? Salah satu IDE terbaik besutan Microsoft ini dibekali dengan sejuta fitur dan plugin yang membuat kita betah untuk menggunakannya. IDE ini bisa digunakan untuk banyak tujuan seperti membuat website, web apps, web services, mobile apps, hingga desktop apps. Tidak heran ia dapat mendukung banyak bahasa seperti C++, Java, Swift, Visual Basic, Python, Go, JavaScript, PHP, CSS, SQL, PowerShell, BASH, dan lainnya.Di posting kali ini, saya akan menjabarkan bagaimana merombak VS Code menjadi IDE yang minimalis dan juga canggih.Yang Kamu Butuhkan Git bash Shell: Zsh Framework: Oh My Zsh Theme: Powerlevel10k Theme: GitHub Theme Icon packs: Material Icon Theme GitLens Remote Development Customize UI" }, { "title": "Percantik Tampilan Windows Terminal WSL Ubuntu Menggunakan Zsh (Z shell)", "url": "/posts/percantik-windows-terminal-menggunakan-zsh/", "categories": "", "tags": "linux, windows, wsl, shell, terminal, zsh", "date": "2022-02-28 13:19:00 +0700", "snippet": "Ingin rupa Windows Terminal kamu berubah dari yang super monoton old school menjadi lebih fresh seperti ini?Yang Kamu Butuhkan Terminal: Windows Terminal (tersedia gratis di Microsoft Store) Font: Cousine Nerd Font Mono Shell: Zsh Shell Framework: Oh My Zsh Shell Theme: Powerlevel10k WSL Ubuntu (Apa itu WSL?)InstalasiLangkah 1 : Instal Windows TerminalBuka Microsoft Store &amp;gt; cari aplikasi Windows Terminal &amp;gt; klik install.Kenapa harus Windows Terminal? Dibandingkan dengan terminal lain, aplikasi ini punya banyak keunggulan seperti dukungan multi tab, tema yang bisa diubah-ubah, dan bahkan kita bisa mengganti latarnya dengan gambar GIF. Selain itu, terminal ini juga sudah terkonfigurasi secara otomatis dengan PowerShell, CMD, dan WSL. Buka aplikasi dan kamu ready to go.Langkah 2 : Instal Font MonospacePowerlevel10k banyak menggunakan simbol yang tidak umum sehingga kamu harus mengganti font bawaan di terminal agar tidak ada karakter kotak-kotak, tanda tanya, atau sebagainya yang menandakan bahwa suatu simbol tidak dapat dirender oleh font bawaan.Perlu diingat bahwa jenis font yang harus diunduh adalah monospace. Contohnya pada gambar pertama, font yang saya gunakan adalah Cousine Nerd Font Mono. Kamu bisa mengunduh font gratis lainnya di Nerd Fonts, lalu ekstrak dan instal semua file font .otf.Langkah 3 : Ubah Font BawaanLangkah selanjutnya adalah mengubah font bawaan di Windows Terminal. Caranya yaitu buka Windows Terminal &amp;gt; Settings &amp;gt; Ubuntu &amp;gt; Appearance &amp;gt; Font Face &amp;gt; ganti dengan font yang barusan telah kamu instal &amp;gt; Save.Langkah 4 : Instal ZshSekarang kita perlu menginstal Zsh di WSL. Buka Windows Terminal, pilih Ubuntu, lalu jalankan perintah ini untuk menginstal Zsh.sudo apt updatesudo apt install zshJika kamu menggunakan distro Linux yang berbeda, silahkan baca dokumentasi Zsh atau dokumentasi package manager distro kamu.Langkah 5 : Instal Oh My ZshOh My Zsh adalah framework shell Zsh yang nantinya memudahkan kita untuk menyesuaikan apa saja, termasuk mengganti tema dan menambah plugin.sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;Langkah 6 : Instal Powerlevel10kHal yang harus kita instal berikutnya adalah tema Powerlevel10k dengan perintah berikut.git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10kTema ini juga punya fitur wizard setup-nya sendiri sehingga hanya cukup menekan beberapa tombol saja. Mirip seperti installation wizard Windows yang hanya next, next, i agree, install.Setelah proses setup telah selesai, kamu perlu mengedit file ~/.zshrc dan mengganti ZSH_THEME= menjadi ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;. Tutup dan buka kembali Windows Terminal.Langkah 7: Ubah Default ProfileAlih-alih PowerShell atau CMD, agar WSL Ubuntu terbuka tiap kali kamu membuka Windows Terminal, ubah pengaturannya degan cara: Buka Windows Terminal &amp;gt; Settings &amp;gt; Startup &amp;gt; Default Profile &amp;gt; pilih Ubuntu &amp;gt; Save.Langkah 8 (opsional): Edit file settings.json Penting! Silahkan backup file settings.json sebelum mengubahnya secara manual.Agar terminal kamu sama persis dengan yang di gambar paling atas, terutama di bagian transparansi dan warna latar teks, edit file settings.json dengan cara: Buka Windows Terminal &amp;gt; Settings &amp;gt; Open JSON File &amp;gt; cari di bagian pengaturan WSL Ubuntu (biasanya &quot;name&quot;: &quot;Ubuntu&quot;) &amp;gt; lalu sesuaikan menjadi seperti berikut.{ &quot;guid&quot;: &quot;{2c4de342-38b7-51cf-b940-2309a097f518}&quot;, &quot;name&quot;: &quot;Ubuntu&quot;, &quot;hidden&quot;: false, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;font&quot;: { &quot;face&quot;: &quot;Cousine Nerd Font Mono&quot; }, &quot;colorScheme&quot;: &quot;xcodephile&quot;, &quot;useAcrylic&quot;: true, &quot;acrylicOpacity&quot;: 0.8}Masih di file settings.json, di bagian schemes tambahkan satu blok berikut:{ &quot;name&quot;: &quot;xcodephile&quot;, &quot;background&quot;: &quot;#282C34&quot;, &quot;black&quot;: &quot;#282C34&quot;, &quot;blue&quot;: &quot;#0085CE&quot;, &quot;brightBlack&quot;: &quot;#5A6374&quot;, &quot;brightBlue&quot;: &quot;#0085CE&quot;, &quot;brightCyan&quot;: &quot;#56B6C2&quot;, &quot;brightGreen&quot;: &quot;#3AE872&quot;, &quot;brightPurple&quot;: &quot;#C678DD&quot;, &quot;brightRed&quot;: &quot;#E06C75&quot;, &quot;brightWhite&quot;: &quot;#DCDFE4&quot;, &quot;brightYellow&quot;: &quot;#E5C07B&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#56B6C2&quot;, &quot;foreground&quot;: &quot;#DCDFE4&quot;, &quot;green&quot;: &quot;#3AE872&quot;, &quot;purple&quot;: &quot;#C678DD&quot;, &quot;red&quot;: &quot;#E06C75&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#DCDFE4&quot;, &quot;yellow&quot;: &quot;#E5C07B&quot;}Simpan dan tutup file settings.json.Jika semuanya lancar, seharusnya Windows Terminal kamu sudah sama persis dengan yang saya punya." }, { "title": "WSL, Solusi Menjalankan Perintah Linux di Windows", "url": "/posts/perintah-linux-di-windows/", "categories": "", "tags": "linux, windows, wsl, shell, terminal", "date": "2022-02-26 17:12:00 +0700", "snippet": "Apakah kamu seorang programmer, content creator, dan gamer sekaligus, yang dituntut untuk punya sistem operasi yang mendukung pengembangan perangkat lunak dan juga menawarkan banyak aplikasi dan game? Atau setidaknya, apakah kamu tertarik akan keseksian command Linux namun tidak bisa lepas dari kepraktisan Windows?Jika iya, kamu berada di tempat yang benar. Lanjut scroll ke bawah.Sumber: argeweb.nlAda beberapa solusi yang bisa kita pilih agar bisa menyicipi Linux. Beberapa di antaranya: menjalankan Linux secara virtual di atas Windows atau cara kedua, menginstal kedua sistem operasi secara terpisah di dalam satu komputer.Cara pertama walau terdengar mudah dengan hanya menginstal VirtualBox, namun akan muncul ketergantungan karena Windows harus dihidupkan terlebih dahulu jika ingin menjalankan Linux. Cara kedua, dual boot, akan lebih ribet lagi karena komputer harus dinyalakan ulang jika ingin berganti sistem operasi. Windows dan Linux masih berjalan di sistem yang berbeda.Windows Subsystem for Linux (WSL)Windows Subsystem for Linux adalah compatibility layer yang bertugas untuk menangani operasi tingkat kernel, menerjemahkannya ke instruksi yang dipahami Windows. Dengan adanya layer ini, file executable Linux (dalam format ELF) dapat dijalankan di Windows 10 dan 11.Linux tidak pernah tahu bahwa sebenarnya kernel Windows-lah yang menangani semua permintaannya.Jika ada permintaan yang tidak dapat dipahami kernel Windows, akan ada fallback logic untuk menjalankan perintah di lingkungan Windows. Misalnya mengetik notepad.exe di prompt Linux, maka yang akan terjadi adalah program Notepad akan terbuka dari Windows.WSL bisa jadi pengantar ideal bagi mereka yang masih asing dengan Linux tanpa harus menginstal sistem operasi baru sepenuhnya. Dengan cara ini, kamu bisa menggunakan perintah Linux untuk mengelola serta mengedit file yang biasanya diakses dari File Explorer, mengubah konfigurasi sistem, ngoding (Python dan Git paket bawaan di hampir semua distro Linux), dsb. Windows dan Linux benar-benar berjalan di satu sistem.Prasyarat Windows 11, atau Windows 10 versi 2004+ (Build 19041+) Untuk mengetahui build number, tekan tombol Windows dan R bersamaan, ketik winver, lalu klik OK.InstalasiHanya diperlukan beberapa klik dan ketik saja untuk memperoleh fitur ini.1. Aktifkan fitur WSLBuka Pengaturan &amp;gt; Aplikasi &amp;gt; Fitur Opsional &amp;gt; Fitur Windows Lainnya &amp;gt; Windows Features. Centang Windows Subsystem for Linux lalu klik OK. Windows akan mengunduh beberapa file yang diperlukan secara otomatis. Jika sudah selesai, nyalakan ulang komputer agar WSL bisa diaktifkan.2. Unduh LinuxBuka aplikasi Microsoft Store lalu instal distro Linux yang kamu inginkan, misalnya Ubuntu. Besar ukuran Ubuntu sekitar 200 MB.Setelah selesai mengunduh, Klik Launch untuk memulai proses instalasi Ubuntu. Ini akan membuka jendela command line interface. Di awal instalasi, sistem akan meminta nama pengguna dan sandi yang nantnya digunakan di Ubuntu. Samakan saja dengan akun Windows kamu agar mudah diingat.3. SelesaiYup, selesai. Silahkan buka aplikasi terminal favoritmu. Di sini saya menggunakan Windows Terminal.Saya merekomendasikan Windows Terminal karena punya banyak fitur dan tampilannya mudah dikostumisasikan. Aplikasi ini tersedia gratis di Microsoft Store.Kenapa Harus WSL? Agar bisa menjalankan Docker dan aplikasi GUI Ubuntu (butuh upgrade ke versi WSL 2). Lanjutan dari poin 1, dapat mengembangkan perangkat lunak beserta ekosistemnya dengan lebih leluasa, misalnya menggunakan Kubernetes. Posting ini adalah pendahuluan untuk posting selanjutnya mengenai Percantik Tampilan Windows Terminal WSL Menggunakan Zsh (Z Shell). WSL sudah terkonfigurasi otomatis sehingga langsung dapat digunakan di Windows Terminal.Windows Subsystem for Linux version 2 (WSL 2)WSL 2 bekerja dengan cara yang benar-benar berbeda dari pendahulunya, WSL 1. Ia menjalankan kernel Linux di dalam VM yang sangat ringan. Bukan seperti WSL 1 yang hanya menambahkan layer tambahan.Perbandingan Fitur WSL 1 WSL 2 Integrasi antara Windows dan Linux ✅ ✅ Waktu booting yang cepat ✅ ✅ Managed VM ❌ ✅ Kernel Linux lengkap ❌ ✅ Kompatibilitas full system call ❌ ✅ Peforma sistem file antar OS ✅ ❌ Instalasi WSL 2 Jika sebelumnya kamu sudah menjalankan WSL dan ingin memastikan versi WSL yang sedang digunakan, ketik perintah berikut di PowerShell atau CMD: wsl --list --verbose. Perhatikan di kolom Version.Setelah menyelesaikan langkah instalasi di atas, ketik perintah wsl --set-version &amp;lt;DISTRIBUTION_NAME&amp;gt; &amp;lt;VERSION&amp;gt; (contoh: wsl --set-version ubuntu 2) di PowerShell atau CMD. Pastikan sebelumnya kamu telah mencentang fitur opsional Windows yang bernama Virtual Machine Platform (checkbox-nya berada di lokasi yang sama dengan yang ini). Cukup lakukan itu saja untuk mengganti versi. Verifikasi dengan menjalankan perintah wsl --list --verbose.Perintah DasarJalankan perintah-perintah dasar WSL berikut di PowerShell atau di CMD. Buka WSL terminal wsl Lihat semua distro Linux yang tersedia untuk diunduh wsl --list --online Instal distro wsl --install --distribution &amp;lt;DISTRIBUTION_NAME&amp;gt; Lihat semua distro yang telah terinstal wsl --list --verbose Ubah versi WSL wsl --set-version &amp;lt;DISTRIBUTION_NAME&amp;gt; &amp;lt;VERSION&amp;gt; Ubah versi default WSL wsl --set-default-version &amp;lt;VERSION&amp;gt; Lihat status WSL saat ini wsl --status Tautan Eksternal docs.microsoft.com/en-us/windows/wsl/install docs.microsoft.com/en-us/windows/wsl/compare-versions docs.microsoft.com/en-us/windows/wsl/basic-commands " }, { "title": "[Skripsi] Merancang Adaptive-IPS untuk Mencegah Serangan Siber di Jaringan SDN Menggunakan Logika Fuzzy", "url": "/posts/skripsi/", "categories": "", "tags": "network, security, sdn, ips, fuzzy", "date": "2022-02-11 22:42:00 +0700", "snippet": "DeskripsiSemakin tinggi lalu lintas yang hilir mudik melewati suatu jaringan, semakin tinggi pula kemungkinan terjadinya ancaman keamanan siber. Salah satu solusi untuk mencegahnya yaitu menggunakan perangkat lunak bernama Snort yang dapat mendeteksi aktivitas mencurigakan dengan cara memindai lalu lintas yang masuk dan keluar. Jika terbukti berbahaya, maka Snort akan melakukan pemblokiran akses berdasarkan alamat IP selama beberapa saat.Namun muncul satu masalah, Snort tidak dapat beradaptasi terhadap frekuensi dan jenis serangan. Ini berarti durasi waktu pemblokiran akan tetap statis dengan lama waktu yang telah ditentukan sebelumnya, meskipun host melakukan penyerangan dalam frekuensi tinggi dan severity tinggi.Logika Fuzzy diimplementasikan untuk mengatasi masalah tersebut sehingga tercipta IPS yang dapat beradaptasi terhadap frekuensi serangan dan jenis serangan.Ilustrasi. Sumber: unsplash.com/speedoshotsKode sumber dan semua file pendukung tersedia di repositori Github di xcodephile/university-final-project. Untuk informasi mengenai tautan publikasi IEEE dan referensi, silahkan gulir ke bagian Tautan Eksternal di paling bawah.KomponenPengembangan sistem ini melibatkan: Ryu sebagai SDN controller Mininet sebagai emulator jaringan Snort sebagai IPS signature-basedCara KerjaSnort diinstal di application plane dan Ryu ditempatkan di control plane. Semua lalu lintas akan terlebih dahulu melewati Ryu dan selanjutnya akan diperiksa oleh Snort berdasarkan pencocokan dengan basis data yang telah didefinisikan sebelumnya (lihat file myrules.rules di repositori). Jika dinyatakan aman, maka Ryu akan meneruskan ke tujuan. Namun jika terindikasi berbahaya, Snort akan mengirim peringatan serta mengatur lama waktu pemblokiran dengan durasi awal 10 menit. Jika host terus melakukan serangan dalam masa waktu kurang dari atau sama dengan 10 menit, maka waktu pemblokiran akan bertambah sesuai dengan frekuensi dan jenis serangan.Proses dimulai dari file log alert.csv yang merupakan output dari Snort yang berisi informasi timestamp, alamat IP asal, alamat IP tujuan, protokol, dan pesan. File hostInspector.sh akan mengambil baris terakhir dari log tersebut dan mencari selisih waktu antara serangan terakhir dan serangan sebelumnya dari host yang sama. Fuzzy (semua file yang berekstensi *.py) hanya akan dieksekusi jika selisih waktu penyerangan lebih kecil atau sama dengan 10 menit. Output dari fuzzy adalah durasi waktu blokir dalam satuan detik yang nantinya akan berfungsi untuk menjeda proses. File block.sh berfungsi untuk mengirimkan flow entry pemblokiran ke Ryu via REST API. File unblock.sh akan dieksekusi setelah durasi telah mencapai 0 detik dan akan menghapus flow entry pemblokiran.Topologi JaringanSetupLakukan proses instalasi Ryu, Mininet, dan Snort terlebih dahulu yang dokumentasinya dapat dibaca di situs web mereka masing-masing. Jalankan Ryu. ryu-manager ~/ryu/ryu/app/rest_firewall.py Jalankan Mininet dengan opsi controller remote (diarahkan ke Ryu yang telah running) serta custom topologi yang ada di file topologi.py. mn --custom ~/mininet/custom/topologi.py --topo mytopo --controller remote --switch ovsk,protocols=OpenFlow13 Secara default lalu lintas dari dan ke seluruh host akan diblokir oleh Ryu sehingga diperlukan penambahan flow entry dengan cara menjalankan file flowEntry.sh. bash ~/flowEntry.sh Jalankan Snort menggunakan interface s1-eth1 (switch 1 port eth-1). snort -i s1-eth1 -c /etc/snort/snort.conf -l /var/log/snort Jalankan file hostInspector.sh. bash ~/hostInspector.sh PengujianUntuk Pengujian, lakukan uji serangan yang sesuai dengan basis data serangan Snort di file myrules.rules yaitu host discovery (menggunakan metode port scanning) dan DoS agar peringatan bahwa telah terjadi serangan dapat tersimpan ke /var/log/snort/alert.csv.attacker nmap -v -n -sP --send-ip 192.168.0.0/29Sedangkan untuk DoS dapat memanfaatkan tools hping3.attacker hping3 -c 100 -d 120 -S -w 64 -p 53 --flood serverTangkapan layar selama pengujian berlangsungHasilBerikut contoh tangkapan layar ketika mencoba ping ke host yang sedang diblokir.Dua gambar di bawah ini menjelaskan bagaimana hubungan antara interval waktu serangan suatu host dengan durasi blokir untuk masing-masing jenis serangan.Host DiscoveryDoSTautan EksternalKode SumberKode sumber dan semua file pendukung tersedia di github.com/xcodephile/university-final-project.PublikasiPenelitian ini telah dipublikasikan di IEEE dan web kampus.Referensi Utama W. Xia, Y. Wen dan C. H. Foh, “A Survey on Software-Defined Networking,” IEEE Communication Surveys &amp;amp; Tutorials, vol. 17, pp. 27-51, 2015. D. Huang, T. Xing dan Z. Xiong, “SDNIPS: Enabling Software-Defined Networking Based Intrusion Prevention System in Clouds,” CNSM and Workshop, pp. 308-311, 2014. W. El-Hajj, F. Aloul dan Z. Trabelsi, “On Detecting Port Scanning using Fuzzy Based Intrusion Detection System”." } ]
